devops-netology
===============

# Домашнее задание к занятию "6.1. Типы и структура СУБД"

<details><summary>.</summary>

## Введение

> Перед выполнением задания вы можете ознакомиться с [дополнительными материалами](https://github.com/netology-code/virt-homeworks/tree/master/additional/README.md).

</details>

## Задача 1

<details><summary>.</summary>

> Архитектор ПО решил проконсультироваться у вас, какой тип БД 
> лучше выбрать для хранения определенных данных.
> 
> Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:
> 
> - Электронные чеки в json виде
> - Склады и автомобильные дороги для логистической компании
> - Генеалогические деревья
> - Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
> - Отношения клиент-покупка для интернет-магазина
> 
> Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

</details>

> Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

> - Электронные чеки в json виде

Подойдёт NoSQL база, например MongoDB. Во-первых, Json для неё - нативный способ хранения данных. Во-вторых, мне кажется работать со связями многие-ко-многим в NoSQL базе удобней, чем SQL - не нужно заморачиваться с промежуточной таблицей.

> - Склады и автомобильные дороги для логистической компании

Сложно сказать, т.к. никогда не сталкивался с такими задачами, но думаю предполагается поиск какого-то пути по дорогам, логика подсказыавет что подойдут графовые БД. Возможно реляционные, например OpenStreetMaps [использует PostgreSQL](https://wiki.openstreetmap.org/wiki/Database) в качестве основного хранилища данных. 

Есть отдельный вид [пространственных баз данных](https://en.wikipedia.org/wiki/Spatial_database) - в основном это расширения или встроенные возможности СУБД разных типов, реляционных, графовых и документо-ориентированных.

> - Генеалогические деревья

Подойдут реляционные ДБ, это распространённая практика, и позволит гарантировать связанность данных, чтобы при удалении какая-то связь родственников не выпала и не оказалось "разорванного" генеалогического древа.

> - Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации

Для хранения кеша лучше подходят NoSQL базы, т.к. работают быстро. Для этой цели часто используют Memcached. 

> - Отношения клиент-покупка для интернет-магазина

Реляционная БД. За годы они хорошо зарекомендовали себя в сфере eCommerce.

## Задача 2

<details><summary>.</summary>

> Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
> CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
> (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):
> 
> - Данные записываются на все узлы с задержкой до часа (асинхронная запись)
> - При сетевых сбоях, система может разделиться на 2 раздельных кластера
> - Система может не прислать корректный ответ или сбросить соединение
> 
> А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

</details>

> Данные записываются на все узлы с задержкой до часа (асинхронная запись)

По CAP теореме - AP, т.к. асинхронная запись не может дать гарантию консистентности данных.

По PACELC теореме вероятно PA/EL, т.к. задержки в один час скорей всего будет достаточно чтобы устранить небольшие сетевые проблемы, поэтоум логичней делать упор на отзывчивость.

> При сетевых сбоях, система может разделиться на 2 раздельных кластера

По CAP теореме - AP, т.к. если система функционирует, разделённая на 2 части, она так же не может быть консистентной.

По PACELC теореме вероятно PA/EL: явно не описано как именно система должна работать при разделении, но предположу что имеется в виду "разделиться на 2 части и остаться доступной" - в таком случае то же логично делать упор на доступность.

> Система может не прислать корректный ответ или сбросить соединение

По CAP теореме - CP, т.к. условие доступности требует, чтобы запрос всегда завершался корректным ответом.

По PACELC теореме вероятно PC/EC, судя по описанию доступность не так важна, то есть остаётся согласованность.

## Задача 3

> Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

Скорее нет, чем да. 

ACID ориентирован на целостность данных, а BASE на их доступность. 

Принцип "Soft-state" в BASE противоречит сути ACID, при этом ни один из принципов ACID прямо не противоречет сути BASE.

Об этом можно судить косвенно: выполнение требований ACID потребует от СУБД сложных механизмов проверки целостности базы после каждой транзакции, что сделает её менее быстрой, чем любая BASE СУБД, которая тоже должна гарантировать целостность, просто с течением времени.

## Задача 4

<details><summary>.</summary>

> Вам дали задачу написать системное решение, основой которого бы послужили:
> 
> - фиксация некоторых значений с временем жизни
> - реакция на истечение таймаута
> 
> Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
> Что это за система? Какие минусы выбора данной системы?

</details>

> Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
>
> Что это за система? Какие минусы выбора данной системы?

Видимо речь идёт о Redis. Минусы выбора Redis в качествев Pub/Sub системы:
- Может медленно работать, если настроить персистентность
- Без персистентности, можно потерять данные при сбое сервера или перезапуске сервиса
- Настройка кластеризации [может быть нетривиальна и треует особого внимания](https://stackoverflow.com/questions/12675082/pub-sub-and-redis-clustering)
